# chat/sqlgen.py
from __future__ import annotations
from dataclasses import dataclass
from typing import Dict, Iterable, Protocol
import re

from .llm import ask_gemini_text

# =========================
# Allowed schema (Supabase)
# =========================
ALLOWED: Dict[str, set[str]] = {
    "patients": {
        "id",
        "sin",
        "name",
        "subject_initials",
        "gender",
        "date_of_birth",
        "address",
        "phone_number",
        "age",
        "height",
        "weight",
        "bmi",
        "systolic",
        "diastolic",
        "smoking_habit",
        "smoker",
        "drinking_habit",
        "hemoglobin",
        "random_blood_glucose",
        "sgot",
        "sgpt",
        "alkaline_phosphatase",
    },
    "predictions_predictionresult": {
        "sin",
        "subject_initials",
        "prediction",
        "created_at",
    },
}




# Relationships: currently single-table, but keep text for future extension
RELATIONSHIPS = """
- patients: one row per subject (key = patients.sin)
- predictions_predictionresult: prediction results per subject (key = predictions_predictionresult.sin)

Although both tables share sin, do NOT join them in the same query.
Each query must use exactly one table: either patients OR predictions_predictionresult.
"""



# Domain synonyms to bias mapping (map to existing columns only)
SYNONYMS = """
Vocabulary / synonyms (map to columns on patients / predictions):

Patients:
- "subject id", "screening id", "subject number" => patients.sin
- "jenis kelamin", "sex", "gender" => patients.gender
- "umur", "age" => patients.age
- "berat", "weight", "weight in kg" => patients.weight
- "tinggi", "height", "height in cm" => patients.height
- "BMI" => patients.bmi
- "systolic", "systolic blood pressure", "BP atas" => patients.systolic
- "diastolic", "diastolic blood pressure", "BP bawah" => patients.diastolic
- "smoker", "perokok" => patients.smoker
- "smoking habit", "kebiasaan merokok" => patients.smoking_habit
- "drinking habit", "kebiasaan minum alkohol" => patients.drinking_habit
- "hemoglobin", "HB" => patients.hemoglobin
- "blood sugar", "gula darah acak", "RBG" => patients.random_blood_glucose
- "SGOT", "AST" => patients.sgot
- "SGPT", "ALT" => patients.sgpt
- "alkaline phosphatase", "ALP" => patients.alkaline_phosphatase

Predictions:
- "prediction", "predicted label", "model output", "risk category" => predictions_predictionresult.prediction
- "prediction time", "prediction date", "prediction created at" => predictions_predictionresult.created_at
"""

SAFE_SELECT = re.compile(r"^\s*select\b", re.I)
HAS_LIMIT = re.compile(r"\blimit\s+\d+\b", re.I)
DML_DDL_BAD = re.compile(r"\b(insert|update|delete|merge|alter|drop|create|truncate|grant|revoke)\b", re.I)

# =========
# Helpers
# =========
def _schema_hint_from_allowed(allowed: Dict[str, Iterable[str]]) -> str:
    parts = []
    for table, cols in allowed.items():
        parts.append(f"{table}({', '.join(sorted(cols))})")
    return "; ".join(parts)

def _ensure_select_only(sql: str) -> str:
    sql = sql.strip() #
    if ";" in sql:
        # Allow only a *single* trailing semicolon (OWASP A03)
        if sql.count(";") > 1 or not sql.endswith(";"):
            raise ValueError("Multiple SQL statements not allowed.")
    if DML_DDL_BAD.search(sql):
        raise ValueError("Forbidden SQL detected (DML/DDL).")
    if not SAFE_SELECT.match(sql.strip()):
        # try to salvage a SELECT line from multi-line output
        for ln in (x.strip() for x in sql.splitlines()):
            if SAFE_SELECT.match(ln):
                return ln
        raise ValueError("Autogenerated SQL is not a SELECT statement.")
    return sql.strip()

def _ensure_limit(sql: str, default_limit: int = 200) -> str:
    # Append a LIMIT if none present (unless query is aggregate returning a single row)
    if HAS_LIMIT.search(sql):
        return sql
    # Heuristic: if has GROUP BY or window or no WHERE, still okay to cap
    return f"{sql.rstrip().rstrip(';')} LIMIT {default_limit};"

# =========================
# SOLID components
# =========================

# ISP & DIP: a tiny interface/port so we can inject any LLM implementation in tests.
class SQLLLM(Protocol):
    def complete(self, prompt: str) -> str: ...

# Default adapter using your existing function (keeps tests/backward-compat).
class GeminiSQLLLM:
    def complete(self, prompt: str) -> str:
        return ask_gemini_text(prompt) or ""

# SRP: builds the prompt string only.
@dataclass(frozen=True)
class SQLPromptBuilder:
    relationships: str = RELATIONSHIPS
    synonyms: str = SYNONYMS

    def build(self, user_message: str, schema_hint: str) -> str:
        return f"""You are a senior data analyst writing SQL for PostgreSQL.

GOAL:
Write ONE safe, production-ready **SELECT-only** SQL query.

ABSOLUTE RULES:
- Output ONLY the SQL (no backticks, no prose, no explanation).
- The first token MUST be SELECT.
- NEVER use INSERT/UPDATE/DELETE/DDL/TRUNCATE/ALTER/DROP/CREATE.
- NEVER use JOIN. Only ONE table may appear in the FROM clause.

TABLE + COLUMN RULES (CRITICAL):
You may ONLY reference the following tables and columns:
{schema_hint}

Valid tables and aliases:
- patients => alias as p
- predictions_predictionresult => alias as pr

COLUMN SELECTION RULES:
- When using **patients**, ALWAYS use:  
    SELECT * FROM patients p

- When using **predictions_predictionresult**, NEVER use SELECT *.  
  Instead, you MUST explicitly select ONLY the following columns (id is forbidden):
    pr.sin,
    pr.subject_initials,
    pr.prediction,
    pr.created_at

  Example of allowed pattern:
    SELECT pr.sin, pr.subject_initials, pr.prediction, pr.created_at
    FROM predictions_predictionresult pr
    WHERE ...

Under NO circumstances may pr.id be selected.

STRICT ANTI-HALLUCINATION RULES:
- Use column names EXACTLY as written.
- NEVER invent new column names (forbidden examples: prediction_id, sin_id, pred_label, etc.)
- If unsure which table to use, fall back to a minimal safe query:

  SELECT * FROM patients p LIMIT 10;

TABLE SELECTION GUIDANCE:
- Use patients p when the request is about:
  demographics, vitals, labs, age, gender, height, weight, sgot, sgpt, etc.

- Use predictions_predictionresult pr when the request is about:
  prediction, predicted label, model result, risk, created_at, latest prediction, etc.

ALLOWED STRUCTURE:
- Optional WHERE
- Optional ORDER BY
- Optional LIMIT
- Optional GROUP BY / HAVING (if aggregating)

Examples:

-- patients
SELECT *
FROM patients p
WHERE p.age > 40;

-- predictions
SELECT pr.sin, pr.subject_initials, pr.prediction, pr.created_at
FROM predictions_predictionresult pr
ORDER BY pr.created_at DESC
LIMIT 20;

USER REQUEST:
\"\"\"{user_message}\"\"\"


Write ONLY the final SQL query below:
"""

# SRP: validates and optionally post-processes SQL.
@dataclass(frozen=True)
class SQLPostProcessor:
    default_limit: int = 200

    def validate_select_only(self, sql: str) -> str:
        return _ensure_select_only(sql)

    def maybe_add_limit(self, sql: str, add_default_limit: bool) -> str:
        return _ensure_limit(sql, self.default_limit) if add_default_limit else sql

# OCP & DIP: Orchestrator that depends on abstractions; open for extension.
@dataclass
class SemanticSQLGenerator:
    llm: SQLLLM
    prompt_builder: SQLPromptBuilder
    post_processor: SQLPostProcessor

    def generate(
        self,
        user_message: str,
        schema_hint: str | None = None,
        add_default_limit: bool = True,
    ) -> str:
        schema = schema_hint or _schema_hint_from_allowed(ALLOWED)

        # Build prompt for the LLM
        prompt = self.prompt_builder.build(user_message, schema)

        # Call injected LLM (may be real Gemini or a mocked version in tests)
        raw_sql = self.llm.complete(prompt)

        # âœ… Normalize to string to be robust against mocks / non-str returns
        if not isinstance(raw_sql, str):
            raw_sql = str(raw_sql)

        raw_sql = (raw_sql or "").strip()
        if not raw_sql:
            raise ValueError("llm_empty_sql")

        # Validate and post-process
        sql = self.post_processor.validate_select_only(raw_sql)
        sql = self.post_processor.maybe_add_limit(sql, add_default_limit)
        print("\n[SQLPromptBuilder] Generated SQL Prompt:\n")
        print(sql)
        print("\n-----------------------------------------\n")

        return sql


# =========================
# Public API (backward-compatible)
# =========================
def generate_semantic_sql(
    user_message: str,
    schema_hint: str | None = None,
    add_default_limit: bool = True
) -> str:
    """
    Generate a single safe SELECT for PostgreSQL from natural language.
    - Uses only whitelisted tables/columns
    - Joins across tables on patients.sin by default
    - SELECT-only; optional automatic LIMIT
    """
    generator = SemanticSQLGenerator(
        llm=GeminiSQLLLM(),
        prompt_builder=SQLPromptBuilder(),
        post_processor=SQLPostProcessor(default_limit=200),
    )
    return generator.generate(
        user_message,
        schema_hint=schema_hint,
        add_default_limit=add_default_limit,
    )
