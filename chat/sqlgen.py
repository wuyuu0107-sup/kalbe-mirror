# chat/sqlgen.py
from __future__ import annotations
from dataclasses import dataclass
from typing import Dict, Iterable, Protocol, Optional
import re

from .llm import ask_gemini_text

# =========================
# Allowed schema (Supabase)
# =========================
ALLOWED: Dict[str, set[str]] = {
    "patients": {
        "sin", "subject_initials", "study_drug", "screening_date", "gender",
        "date_of_birth", "age", "weight_kg", "height_cm", "bmi",
        "smoker_cigarettes_per_day",
    },
    "vitals": {
        "sin", "systolic_bp", "diastolic_bp", "heart_rate",
    },
    "serology": {
        "sin", "hbsag", "hcv", "hiv",
    },
    "urinalysis": {
        "sin", "ph", "density", "glucose", "ketone", "urobilinogen",
        "urobilinogen_unit", "bilirubin", "blood", "leucocyte_esterase", "nitrite",
    },
    "hematology": {
        "sin", "hemoglobin", "hemoglobin_unit", "hematocrit",
        "leukocyte", "erythrocyte", "thrombocyte", "esr",
    },
    "clinical_chemistry": {
        "sin", "bilirubin_total", "alkaline_phosphatase", "sgot",
        "sgpt", "ureum", "creatinine", "random_blood_glucose",
    },
    # NOTE: raw_intake is intentionally excluded from analytics
}

# Relationships (hint to LLM): all analytic tables join via patients.sin
RELATIONSHIPS = """
- Primary entity: patients (one row per subject, key = patients.sin)
- Join key across all modules is "sin"
    vitals.sin = patients.sin
    serology.sin = patients.sin
    urinalysis.sin = patients.sin
    hematology.sin = patients.sin
    clinical_chemistry.sin = patients.sin
"""

# Domain synonyms to bias mapping (don’t change DB names)
SYNONYMS = """
Vocabulary / synonyms (map to columns):
- "HBsAg" => serology.hbsag
- "SGOT", "AST" => clinical_chemistry.sgot
- "SGPT", "ALT" => clinical_chemistry.sgpt
- "RBG", "random glucose", "kadar gula acak" => clinical_chemistry.random_blood_glucose
- "hemoglobin" => hematology.hemoglobin
- "hematocrit" => hematology.hematocrit
- "leukocyte", "leukosit" => hematology.leukocyte
- "erythrocyte", "eritrosit" => hematology.erythrocyte
- "platelet", "trombosit" => hematology.thrombocyte
- "ESR", "laju endap darah" => hematology.esr
- "alkaline phosphatase", "ALP" => clinical_chemistry.alkaline_phosphatase
- "bilirubin total" => clinical_chemistry.bilirubin_total
- "creatinine" => clinical_chemistry.creatinine
- "ureum", "BUN (approx.)" => clinical_chemistry.ureum
- "blood pressure", "BP", "tekanan darah" => vitals.systolic_bp, vitals.diastolic_bp
- "heart rate", "denyut nadi", "HR" => vitals.heart_rate
- "jenis kelamin", "sex" => patients.gender
- "umur", "age" => patients.age
- "berat", "weight" => patients.weight_kg
- "tinggi", "height" => patients.height_cm
- "BMI" => patients.bmi
"""

SAFE_SELECT = re.compile(r"^\s*select\b", re.I)
HAS_LIMIT = re.compile(r"\blimit\s+\d+\b", re.I)
DML_DDL_BAD = re.compile(r"\b(insert|update|delete|merge|alter|drop|create|truncate|grant|revoke)\b", re.I)

# =========
# Helpers
# =========
def _schema_hint_from_allowed(allowed: Dict[str, Iterable[str]]) -> str:
    parts = []
    for table, cols in allowed.items():
        parts.append(f"{table}({', '.join(sorted(cols))})")
    return "; ".join(parts)

def _ensure_select_only(sql: str) -> str:
    if DML_DDL_BAD.search(sql):
        raise ValueError("Forbidden SQL detected (DML/DDL).")
    if not SAFE_SELECT.match(sql.strip()):
        # try to salvage a SELECT line from multi-line output
        for ln in (x.strip() for x in sql.splitlines()):
            if SAFE_SELECT.match(ln):
                return ln
        raise ValueError("Autogenerated SQL is not a SELECT statement.")
    return sql.strip()

def _ensure_limit(sql: str, default_limit: int = 200) -> str:
    # Append a LIMIT if none present (unless query is aggregate returning a single row)
    if HAS_LIMIT.search(sql):
        return sql
    # Heuristic: if has GROUP BY or window or no WHERE, still okay to cap
    return f"{sql.rstrip().rstrip(';')} LIMIT {default_limit};"

# =========================
# SOLID components
# =========================

# ISP & DIP: a tiny interface/port so we can inject any LLM implementation in tests.
class SQLLLM(Protocol):
    def complete(self, prompt: str) -> str: ...

# Default adapter using your existing function (keeps tests/backward-compat).
class GeminiSQLLLM:
    def complete(self, prompt: str) -> str:
        return ask_gemini_text(prompt) or ""

# SRP: builds the prompt string only.
@dataclass(frozen=True)
class SQLPromptBuilder:
    relationships: str = RELATIONSHIPS
    synonyms: str = SYNONYMS

    def build(self, user_message: str, schema_hint: str) -> str:
        return f"""You are a senior data analyst writing SQL for PostgreSQL.

TASK:
Translate the user's analytics request into ONE safe **SELECT-only** SQL query.

ABSOLUTE RULES:
- Output **only** the SQL (no backticks, no prose).
- The first token MUST be SELECT.
- Use ONLY these tables/columns and nothing else:
  {schema_hint}
- Default joins:
{self.relationships}
  If multiple tables are needed, join them via the shared key "sin".
- Prefer clear aliases: p (patients), v (vitals), s (serology), u (urinalysis), h (hematology), c (clinical_chemistry).
- If user asks for "per patient" attributes + labs, join patients (p) and the relevant module(s).
- Use WHERE for filters derived from the prompt (e.g., age > 30, gender = 'Male').
- If aggregating, include proper GROUP BY.
- If user asks for “top/most/least”, use ORDER BY and a LIMIT.
- NEVER use INSERT/UPDATE/DELETE/DDL.

Domain mapping to help you choose the right columns:
{self.synonyms}

Examples of JOIN patterns you can use:
- SELECT p.sin, p.gender, c.sgot FROM patients p
  JOIN clinical_chemistry c ON c.sin = p.sin
  WHERE c.sgot > 35;

- SELECT p.sin, v.systolic_bp, v.diastolic_bp
  FROM patients p JOIN vitals v ON v.sin = p.sin
  WHERE p.age >= 30;

USER REQUEST:
\"\"\"{user_message}\"\"\"

Write the final SQL below (no comments, no CTEs unless truly needed):
"""

# SRP: validates and optionally post-processes SQL.
@dataclass(frozen=True)
class SQLPostProcessor:
    default_limit: int = 200

    def validate_select_only(self, sql: str) -> str:
        return _ensure_select_only(sql)

    def maybe_add_limit(self, sql: str, add_default_limit: bool) -> str:
        return _ensure_limit(sql, self.default_limit) if add_default_limit else sql

# OCP & DIP: Orchestrator that depends on abstractions; open for extension.
@dataclass
class SemanticSQLGenerator:
    llm: SQLLLM
    prompt_builder: SQLPromptBuilder
    post_processor: SQLPostProcessor

    def generate(
        self,
        user_message: str,
        schema_hint: str | None = None,
        add_default_limit: bool = True,
    ) -> str:
        schema = schema_hint or _schema_hint_from_allowed(ALLOWED)

        # use the injected builder (SRP + DIP)
        prompt = self.prompt_builder.build(user_message, schema)

        raw_sql = (self.llm.complete(prompt) or "").strip()
        if not raw_sql:
            raise ValueError("llm_empty_sql")

        # use the injected post-processor (SRP)
        sql = self.post_processor.validate_select_only(raw_sql)
        sql = self.post_processor.maybe_add_limit(sql, add_default_limit)
        return sql


# =========================
# Public API (backward-compatible)
# =========================
def generate_semantic_sql(
    user_message: str,
    schema_hint: str | None = None,
    add_default_limit: bool = True
) -> str:
    """
    Generate a single safe SELECT for PostgreSQL from natural language.
    - Uses only whitelisted tables/columns
    - Joins across tables on patients.sin by default
    - SELECT-only; optional automatic LIMIT
    """
    generator = SemanticSQLGenerator(
        llm=GeminiSQLLLM(),
        prompt_builder=SQLPromptBuilder(),
        post_processor=SQLPostProcessor(default_limit=200),
    )
    return generator.generate(
        user_message,
        schema_hint=schema_hint,
        add_default_limit=add_default_limit,
    )
