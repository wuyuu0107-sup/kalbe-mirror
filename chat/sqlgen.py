from __future__ import annotations
from typing import Dict, Iterable
import re

# =========================
# Allowed schema (Supabase)
# =========================
ALLOWED: Dict[str, set[str]] = {
    "patients": {
        "sin", "subject_initials", "study_drug", "screening_date", "gender",
        "date_of_birth", "age", "weight_kg", "height_cm", "bmi",
        "smoker_cigarettes_per_day",
    },
    "vitals": {
        "sin", "systolic_bp", "diastolic_bp", "heart_rate",
    },
    "serology": {
        "sin", "hbsag", "hcv", "hiv",
    },
    "urinalysis": {
        "sin", "ph", "density", "glucose", "ketone", "urobilinogen",
        "urobilinogen_unit", "bilirubin", "blood", "leucocyte_esterase", "nitrite",
    },
    "hematology": {
        "sin", "hemoglobin", "hemoglobin_unit", "hematocrit",
        "leukocyte", "erythrocyte", "thrombocyte", "esr",
    },
    "clinical_chemistry": {
        "sin", "bilirubin_total", "alkaline_phosphatase", "sgot",
        "sgpt", "ureum", "creatinine", "random_blood_glucose",
    },
    # NOTE: raw_intake is intentionally excluded from analytics
}

# Relationships (hint to LLM): all analytic tables join via patients.sin
RELATIONSHIPS = """
- Primary entity: patients (one row per subject, key = patients.sin)
- Join key across all modules is "sin"
    vitals.sin = patients.sin
    serology.sin = patients.sin
    urinalysis.sin = patients.sin
    hematology.sin = patients.sin
    clinical_chemistry.sin = patients.sin
"""

# Domain synonyms to bias mapping (don’t change DB names)
SYNONYMS = """
Vocabulary / synonyms (map to columns):
- "HBsAg" => serology.hbsag
- "SGOT", "AST" => clinical_chemistry.sgot
- "SGPT", "ALT" => clinical_chemistry.sgpt
- "RBG", "random glucose", "kadar gula acak" => clinical_chemistry.random_blood_glucose
- "hemoglobin" => hematology.hemoglobin
- "hematocrit" => hematology.hematocrit
- "leukocyte", "leukosit" => hematology.leukocyte
- "erythrocyte", "eritrosit" => hematology.erythrocyte
- "platelet", "trombosit" => hematology.thrombocyte
- "ESR", "laju endap darah" => hematology.esr
- "alkaline phosphatase", "ALP" => clinical_chemistry.alkaline_phosphatase
- "bilirubin total" => clinical_chemistry.bilirubin_total
- "creatinine" => clinical_chemistry.creatinine
- "ureum", "BUN (approx.)" => clinical_chemistry.ureum
- "blood pressure", "BP", "tekanan darah" => vitals.systolic_bp, vitals.diastolic_bp
- "heart rate", "denyut nadi", "HR" => vitals.heart_rate
- "jenis kelamin", "sex" => patients.gender
- "umur", "age" => patients.age
- "berat", "weight" => patients.weight_kg
- "tinggi", "height" => patients.height_cm
- "BMI" => patients.bmi
"""

SAFE_SELECT = re.compile(r"^\s*select\b", re.I)
HAS_LIMIT = re.compile(r"\blimit\s+\d+\b", re.I)
DML_DDL_BAD = re.compile(r"\b(insert|update|delete|merge|alter|drop|create|truncate|grant|revoke)\b", re.I)

def _schema_hint_from_allowed(allowed: Dict[str, Iterable[str]]) -> str:
    parts = []
    for table, cols in allowed.items():
        parts.append(f"{table}({', '.join(sorted(cols))})")
    return "; ".join(parts)

def _ensure_select_only(sql: str) -> str:
    if DML_DDL_BAD.search(sql):
        raise ValueError("Forbidden SQL detected (DML/DDL).")
    if not SAFE_SELECT.match(sql.strip()):
        # try to salvage a SELECT line from multi-line output
        for ln in (x.strip() for x in sql.splitlines()):
            if SAFE_SELECT.match(ln):
                return ln
        raise ValueError("Autogenerated SQL is not a SELECT statement.")
    return sql.strip()

def _ensure_limit(sql: str, default_limit: int = 200) -> str:
    # Append a LIMIT if none present (unless query is aggregate returning a single row)
    if HAS_LIMIT.search(sql):
        return sql
    # Heuristic: if has GROUP BY or window or no WHERE, still okay to cap
    return f"{sql.rstrip().rstrip(';')} LIMIT {default_limit};"

def generate_semantic_sql(user_message: str, schema_hint: str | None = None, add_default_limit: bool = True) -> str:
    """
    Generate a single safe SELECT for PostgreSQL from natural language.
    - Uses only whitelisted tables/columns
    - Joins across tables on patients.sin by default
    - SELECT-only; optional automatic LIMIT
    """
    # Lazy import to avoid cycles
    from .llm import ask_gemini_text

    schema = schema_hint or _schema_hint_from_allowed(ALLOWED)

    prompt = f"""You are a senior data analyst writing SQL for PostgreSQL.

TASK:
Translate the user's analytics request into ONE safe **SELECT-only** SQL query.

ABSOLUTE RULES:
- Output **only** the SQL (no backticks, no prose).
- The first token MUST be SELECT.
- Use ONLY these tables/columns and nothing else:
  {schema}
- Default joins:
{RELATIONSHIPS}
  If multiple tables are needed, join them via the shared key "sin".
- Prefer clear aliases: p (patients), v (vitals), s (serology), u (urinalysis), h (hematology), c (clinical_chemistry).
- If user asks for "per patient" attributes + labs, join patients (p) and the relevant module(s).
- Use WHERE for filters derived from the prompt (e.g., age > 30, gender = 'Male').
- If aggregating, include proper GROUP BY.
- If user asks for “top/most/least”, use ORDER BY and a LIMIT.
- NEVER use INSERT/UPDATE/DELETE/DDL.

Domain mapping to help you choose the right columns:
{SYNONYMS}

Examples of JOIN patterns you can use:
- SELECT p.sin, p.gender, c.sgot FROM patients p
  JOIN clinical_chemistry c ON c.sin = p.sin
  WHERE c.sgot > 35;

- SELECT p.sin, v.systolic_bp, v.diastolic_bp
  FROM patients p JOIN vitals v ON v.sin = p.sin
  WHERE p.age >= 30;

USER REQUEST:
\"\"\"{user_message}\"\"\"

Write the final SQL below (no comments, no CTEs unless truly needed):
"""
    sql = (ask_gemini_text(prompt) or "").strip()

    sql = _ensure_select_only(sql)

    if add_default_limit:
        sql = _ensure_limit(sql)

    return sql
